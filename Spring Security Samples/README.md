## Introduction to Spring Security Internal Flow

- Spring Security Filters will intercept each and every request, and create an Authentication object using the username and password. And hand it over to Authentication Manager.
- Authentication Manager will check what all Authentication Provider are available inside web application. And inside these Authentication Provider, we can define actual logic of authentication such as whether I want to validate user credentials from a DB or an LDAP server or from Authorization server. There can be multiple Authentication Provider in the web app.
- Authentication Manager will identify all available Authentication Provider(s) and will try respond to end user that authentication is fail or success to Spring Security Filters which will store the Authentication object inside Security Context along with details like whether authentication was successful or not, what is session id?
- For example -
    - UsernamePasswordAuthenticationFilter will create an object of UsernamePasswordAuthenticationToken class, this class implements the Authentication object. This filter would handover this object to Authentication Manager.
    - Authentication Manager will interact with all Authentication Provider inside spring framework or developer defined until it gets a success or all failures. All the logic of authentication and authorisation would be inside the Authentication Provider.
    - For default flow, Authentication Manager would invoke one of the spring security provided authentication provider which is DaoAuthenticationProvider. Inside the authenticate method of this provider, retrieveUser method would be called, this method is defined in user details manager or service. All the Authentication Provider would take help from user details manager or service (also the Password Encoder).
    - As discussed DaoAuthenticationProvider will take help from one of the user details manager implementation. And that class is InMemoryUserDetailsManager. The spring security framework will invoke this InMemoryUserDetailsManager whenever user details are stored in memory of the application such as in application.properties.
    
Note:
- If a url is secured or protected then only filters would be invoked. These filters further invoke authentication manager, which further invokes all available authentication provider and each auth provider uses user details manager implementations (along with password encoder) and will success/fail the authentication.

## How multiple requests work without credentials?

- JSESSIONID is generated by the spring security backend server and is stored as a cookie in browser. Same cookie will be sent by browser to backend server for each request.
- This JSESSIONID is the default behaviour and is not super secure. There are some advanced approaches with help of jwt token and oauth framework.

## Default security configuration

By default, all endpoints would be secured by spring security framework. This behaviour is due to code present inside the method defaultSecurityFilterChain(HttpSecurity http) of class SpringBootWebSecurityConfiguration.

```
SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
http.authorizeHttpRequests((requests) -> {
((AuthorizedUrl)requests.anyRequest()).authenticated();
});
http.formLogin(Customizer.withDefaults());
http.httpBasic(Customizer.withDefaults());
return (SecurityFilterChain)http.build();
}
```

requests.anyRequest()).authenticated()
- Here we are telling that any request coming to application has to be authenticated.

http.formLogin(Customizer.withDefaults()); and http.httpBasic(Customizer.withDefaults());
- Here we are telling that any request can come from http form ui OR rest api invocation via http basic standards.

Note:
- When we use @Configuration annotation, it is an indication to spring boot framework that we have certain configurations defined in this class so during the startup it is going to scan for all the beans that we have declared inside this class.
- SecurityFilterChain bean is very important when we want to define our custom security requirements.
- We can mention exact path name or even regex pattern inside requestMatchers.

## Custom security configuration

Some custom configuration:
```
SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
http.authorizeHttpRequests((requests) -> {
requests
.requestMatchers("/myAccount", "/myBalance", "/myLoans", "myCards").authenticated()
.requestMatchers("/notices", "/contact").permitAll();
}).formLogin(Customizer.withDefaults()).httpBasic(Customizer.withDefaults());
return http.build();
}
```

Deny all requests (It would still ask for authentication credentials but show 403 unauthorised even on successful login, it is denying all requests after authentication and doesn't mean denying authentication):
```
http.authorizeHttpRequests((requests) -> {
requests.anyRequest().denyAll();
}).formLogin(Customizer.withDefaults()).httpBasic(Customizer.withDefaults());
```

Allow all requests:
```
http.authorizeHttpRequests((requests) -> {
requests.anyRequest().permitAll();
}).formLogin(Customizer.withDefaults()).httpBasic(Customizer.withDefaults());
```

Note:
- The permitAll() configuration allows unrestricted access. That's why it doesn't show login page.
- Whereas with denyAll(), the denial of page access comes after completing of Authentication. That's why we will see login page with denyAll.

## Defining and Managing Users

- How to configure multiple users inside application memory?
    - Fine only for lower env but not prod env.
- Creating and storing user creds inside a DB.
    - The creds can also be stored in any storage system or authorization server like Okta, KeyCloak using the OAuth2 framework.

Note: Instead of defining a single user inside app.properties, as a next step, we can define multiple users along with their authorities with the help of InMemoryUserDetailsManager and UserDetails.

```
@Bean
public InMemoryUserDetailsManager userDetailsService() {
 // withDefaultPasswordEncoder is for plaintext password
 UserDetails admin = User.withDefaultPasswordEncoder()
   .username("admin")
   .password("123")
   .authorities("admin")
   .build();
 
 UserDetails user = User.withDefaultPasswordEncoder()
   .username("user")
   .password("123")
   .authorities("read")
   .build();
 
 return new InMemoryUserDetailsManager(admin, user);
} 
```

Couple of interfaces for user management, which are called by AuthenticationProvider:

- UserDetailsService: Interface to load/retrieve user data.
    - loadUserByUsername(String username)
- UserDetailsManager: An extension of UserDetailsService which provides the ability to create new users and update existing ones.
    - createUser(UserDetails user)
    - updateUser(UserDetails user)
    - deleteUser(String username)
    - changePassword(String oldPassword, String newPassword)
    - userExists(String username)
- InMemoryUserDetailsManager is one of the implementations of these 2 above interfaces.
- AuthenticationProvider will return an object of Authentication and UserDetailsService implementation like InMemoryUserDetailsManager will return an object of UserDetails.

Note:
- JdbcUserDetailsManager also implements GroupManager. With the help of GroupManager, we can create groups and we can assign the users into groups. Group is a collection of authorities.

users.ddl script:
```
create table users(username varchar_ignorecase(50) not null primary key,password varchar_ignorecase(500) not null,enabled boolean not null);
create table authorities (username varchar_ignorecase(50) not null,authority varchar_ignorecase(50) not null,constraint fk_authorities_users foreign key(username) references users(username));
create unique index ix_auth_username on authorities (username,authority);
```
Note:
- https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/jdbc.html
- If we want custom schema for users and not what spring security framework provides by default then we cannot use JdbcUserDetailsManager in that case and would have to use create a custom implementation of UserDetailsManager where the logic to load, create, update user, etc is as per our custom schema just like spring team did for JdbcUserDetailsManager.


### Implementing UserDetailsService

- By implementing UserDetailsService, we have provided logic to spring security framework to perform at the time of user authentication.
- UserDetailsManager can be implemented to add logic for create user, update user, user exists, etc. However it is not absolute necessary to implement this class from spring security perspective as these user crud operations can be performed via rest apis as well i.e. we don't want to involve spring security when we are creating, updating or deleting user.

Note:
- By default spring security is going to deny all POST / PUT type requests to avoid CSRF attack.

## Password Management with PasswordEncoders

Encoding:
- Involves no secret and is completely reversible.
- Encoding can't be used for securing data. Some publicly accessible algorithms for encoding: ASCII, BASE64, etc.

Encryption:
- Involves use of secret called "key".
- Reversible using decryption with help of "key". As long as "key" is confidential, encryption can be considered as secured.
- Acceptable for app related credentials but not user credentials.
- Better than encoding approach for managing end user passwords.

Hashing:
- Data once hashed is non-reversible, one cannot determine original data from hash value generated.
- During password comparison, the text entered by user would be passed to hash function and output would be a hash string or hash text, this hash text will internally have a hash value. This hash string would be compared with hash string stored in DB as password, these hash strings could be different but if the hash value corresponding to these 2 hash strings would be the same then it would imply these hashes were generated corresponding to same plaintext string.
- For this we can use password encoder available in spring security.


PasswordEncoder interface has following methods:

- String encode(CharSequence rawPassword);
- boolean matches(CharSequence rawPassword, String encodedPassword)
    - rawPassword is the password entered by user.
    - encodedPassword is the password stored in the DB. This is the hash text corresponding to the plaintext password.

Important: BCryptPasswordEncoder uses BCrypt hashing algorithm.

### Where is password matching logic written?

- DaoAuthenticationProvider will have logic to check if presented password i.e. user entered password and password inside storage are matching.
- This password matching check is in DaoAuthenticationProvider and not in UserDetailsService implementation class (this class should ONLY return a User object and is NOT for password validation).

## Custom AuthenticationProvider

- When we want to have custom authentication logic then we will have to write your own AuthenticationProvider, and inside that we need to write all the authentication logic.
- Spring security filter will convert user entered creds into an Authentication object. Post that, ProviderManager will invoke all available AuthenticationProvider.
- There can be multiple AuthenticationProvider depending on usecase such as one provider to accept username and password, other provider to  accept oauth2 and another provider to accept otp authentication.

There are 2 methods in AuthenticationProvider interface:
- Authentication authenticate(Authentication authentication)
    - The input is an authentication object will consists of username and credentials.
    - The output is also an authentication object which should now have the information that whether the authentication was successful or not, this way the AuthenticationManager can decide whether to invoke other available AuthenticationProvider or not.
- boolean supports(Class<?> authentication)
    - Using this method, we are telling spring security for what type of authentication my AuthenticationProvider needs to be invoked. One such example is UsernamePasswordAuthentication.
    - UsernamePasswordAuthentication is used to authenticate user with username and password.
    
## CORS

- CORS stands for cross origin resource sharing, it is a protocol that enables a browser client to interact with resources from a different origin.
- "other origins" means the URL being accessed differs from the location that the javascript is running from, by having:
    - a different scheme (http or https)
    - a different domain
    - a different port
- By default, browser will enforce CORS by default.

- CORS restrictions are enforced by web browsers.
- The browser will look for Access-Control-Allow-Origin in the response headers - otherwise you could tell the browser to trust anything, exactly what CORS prevents. (The server side has to decide if requests are allowed)
- It's important to note that while CORS is enforced by browsers, it doesn't affect direct server-to-server communication or other types of non-browser interactions.
- If your service-to-service communication doesn't involve a browser, CORS might not be relevant, and the communication might not be subject to CORS restrictions.

What configurations can be done at backend to allows CORS?
- @CrossOrigin annotation can be added on top of a class or method (usually the controller class) like:
    - @CrossOrigin(origins = "*") // will allow any domain
    - @CrossOrigin(origins = "http://localhost:4200") // will allow this specific domain
- Instead of mentioning @CrossOrigin annotation on all controller inside our web app, we can define CORS related config globally using Spring security.

How does the browser understands the configuration done on backend related to CORS?
- Usually browsers will make a pre-flight request i.e. before making the actual API call (for different origins), the browser will make a pre-flight request to backend server saying that this is the origin communicating with you and are you fine with that? 
- If backend app says its a valid origin THEN the browser is going to send the actual request to the backend.

### CORS Flow Example

- localhost:4200 is opened on browser.
- there is a call which is made to backend service running on port localhost:8080 by clicking on a button on frontend app, running on localhost:4200, here the origin of destination is different i.e. cross-origin.
- the browser, will enforce CORS by default.
- i.e. the browser, will first make a preflight request to backend service to check if localhost:4200 is allowed to call them, if backend server running on localhost:8080 says yes then only actual API call is made to localhost:8080 from localhost:4200.
    - It is responsibility of backend developer to configure these CORS details to allow/deny request from an origin.

Note:
- The .ts or typescript files will be compiled into javascript during the compilation process, the browsers can only understand javascript and not the typescript. This typescript is an advanced version of javascript. In angular, we write in .ts/typescript.
- https://collabnix.com/how-to-install-and-configure-nvm-on-mac-os/

## CSRF

- Unlike CORS, CSRF is a security vulnerability, it is not a protection inside the browser. CSRF is a security vulnerability which hackers will use to steal the data from the web app or to execute some privileged actions inside the web app.
- By default, spring security provides CSRF protection. How is it going to protect from CSRF attacks? It will not allow any POST or PUT operations that are going to update or create data.

Problem Description:
- CSRF (Cross-Site Request Forgery) attack aims to perform an operation in a web app on behalf of a user without their explicit consent. In general, it doesn't directly steal the user's identity but it exploits the user to carry out an action without their will.
- For every website, there are some cookie created and saved on browser against the domain name, so that domain like Netflix doesn't have to ask you for credentials again and again.
- FYI cookies created by one domain will be shared/used by other domains, the browser ensures this.
- Now assume the user goes to some other website and clicks on a malicious link there, that link could make a /changeEmail POST request to Netflix or domain website. The browser will make a request to backend of Netflix and would also send cookie details to Netflix.com.
- If the Netflix hasn't implemented CSRF, it wouldn't be able to differentiate whether the request is coming from their website or malicious website.

Solution:
- On authentication to domain like Netflix, apart from authentication-related cookie, another cookie would be sent by backend which is CSRF-related cookie, these cookies would obviously be stored inside browser.
- Now lets say user clicks on malicious link on fraudulent website, the cookies created specific to Netflix would be sent to Netflix website as part of request made by clicking on malicious link (/changePassword) but this time the request would rejected/forbidden by Netflix.
- This is because the backend would expect this CSRF token to be present in request body or headers, and this logic would be present inside javascript of Netflix website. Since the browser restricts that a domain can access cookies created only corresponding to it, therefore only Netflix can access the cookies created corresponding to it i.e. read CSRF token cookie and not the fraudulent website. Now since fraud website cannot read Netflix's domain cookies, it cannot add same in request header or body as well.

Important:
- We can disable CSRF for those POST APIs which are publicly accessible i.e. doesn't require user creds. CSRF attack and protection are meant for the secured APIs.

## AuthN vs AuthZ

- Authorization determines level of access user has to the application, it needs user's privilege or role for same. 
- If AuthN fails, 401 is thrown. If AuthZ fails, 403 is thrown.

### How are Authorities stored inside Spring Security?

- Authorities/Roles info in spring security is stored inside GrantedAuthority object.
- There is one method called getAuthority() inside GrantedAuthority class which return the name of the authority or role.
- SimpleGrantedAuthority is the default implementation of GrantedAuthority interface inside spring security framework.
- The User object (implementation of UserDetailsService interface) and UsernamePasswordAuthenticationToken object (implementation of Authentication interface) contain getAuthority() method which returns a list of authorities with the given user.

Note:
- Whenever we don't want a field to be part of json communication (json request and response) then we can use @JsonIgnore annotation.

In Authority class,
```
// Establishing link with Customer table
@ManyToOne // Many Authority can be mapped to ONE customer
@JoinColumn(name = "customer_id")
private Customer customer;
```

In Customer class,
```
// Establishing link with Authority table
@JsonIgnore
@OneToMany(mappedBy = "customer", fetch = FetchType.EAGER) // mappedBy=fieldName in Authority POJO
// One Customer can be mapped to Many Authority
private Set<Authority> authorities;
```

- By below json property we mean that we always want this field in the json request but we won't send this field back in Json response i.e. this field would be available at time of json deserialisation but not at the time of json serialisation.
```
@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
String password;
```

### Configuring Authorities inside Spring security

We can use 3 methods to enforce authorization in spring security:
- hasAuthority()
    - Accepts a single authority against an endpoint and user will be validated against the single authority mentioned. Only users having the SAME authority configured can invoke the endpoint.
- hasAnyAuthority()
    - Accepts multiple authorities against an endpoint and user will be validated against the authorities mentioned. Only users having ANY of the authority configured can invoke the endpoint.
- access()
    - We can use SpEL and its operators like AND, OR, etc. and make very customisable authorities.

### Authority vs Role

- Authority is like an individual privilege or an action. It is used to restrict access in a fine-grained manner. Example - VIEWACCOUNT, VIEWCARDS, etc.
- Role is like a group of privileges/actions. It is used to restrict access in a coarse-grained manner. Example - ROLE_ADMIN, ROLE_USER, etc.
- Roles are also represented using the same contract GrantedAuthority and we can use SimpleGrantedAuthority object for Role as well. When defining a role, its name should start with ROLE_ prefix. This prefix specifies the difference/differentiates between a role and an authority.

### Configuring Roles inside Spring security

We can use below methods to enforce authorization via ROLES in Spring Security:
- hasRole()
    - Accepts a single role name for which the endpoint(s) will be configured and user will be validated against this single role. Only users with SAME role configured can invoke the endpoint.
- hasAnyRole()
    - Accepts multiple roles for which the endpoint will be configured and user will be validated against the roles mentioned. Only users having ANY of the role can invoke the endpoint.
- access()
    - We can use SpEL and its operators like AND, OR, etc. and make very customisable roles.

Note: ROLE_ prefix is only to be used while configuring the role in DB. But when we configure the roles, we do it only mention its name. The reason is when we call hasRole() then Spring Security would internally add ROLE_ prefix, so we don' t need to add it manually.

### Writing custom filter in Spring security

- Filters inside Java web apps can be used to intercept each request/response and do some pre work before our business logic. So using the same filters, Spring Security enforce security based on our configurations inside a web application.
- Filters are servlet components which are leveraged in Spring Security as well. Example of in-built Spring Security filters: UsernamePasswordAuthFilter, BasicAuthFilter, etc.
- A filter is a component which receives request, process its logic and handover to the next filter in the chain.
- Spring security is based on a chain of servlet filters. Each filter has a specific responsibility and depending on config, the filters can be added or removed. We can add custom filters as well.

```
# FilterChainProxy class has all logic of chaining the inbuilt filters of Spring Security
logging.level.org.springframework.security.web.FilterChainProxy=DEBUG
```

Aim: Creating custom filter and injecting that into spring security filter chain.
Steps:
- Implement Filter interface from jakarta.servlet package. Override doFilter() method to add custom logic. This method has 3 parameters: ServletRequest, ServletResponse and FilterChain (this object is used to forward the request to the next filter in the chain).
- This custom filter can be added to spring security chain either before, after, or at the position of a known.
    - addFilterBefore(filter, class): adds the filter before position of the specified filter class.
    - addFilterAfter(filter, class)
    - addFilterAt(filter, class)

Instead of implementing Filter (and writing business logic in doFilter() method), we can consider other options as well:
- GenericFilterBean: Provides all details about config, init parameters and servlet context.
- OncePerRequestFilter: Recommended to use. This Filter will ensure that a filter is executed only once per request. There can be scenarios where servlet container can invoke a filter multiple times for various reasons. BasicAuthenticationFilter implements this  OncePerRequestFilter. When using this filter, the custom business logic needs to be mentioned in doFilterInternal() method.

### Token based Auth using JWT

- JSESSIONID cookie value is a random string and doesn't give ability to store some user data inside the token/cookie value.
- A token can be a plain string of format UUID or JWT (Json Web Token) usually that get generated when the user is authenticated for the first time during login.
- On every request to a restricted resource, the client sends the access token in the Authorization header. The server then validates the token, and ifs its valid, returns the secure resource to the client.

Benefit of JWT:
- JWT can be used to share certain user related data in the token itself which will reduce the burden of maintaining such details in the sessions on server side, the backend services can be completely stateless and they don't need to remember anything.

Format:
A JWT token has 3 parts, each separated by a period(.)
```
<Header>.<Payload>.<Signature>(Optional)
```
- Inside the JWT header, we store the metadata/info related to the token. If I chose to sign the token,  the header will contain name of the algo that generated the signature. The header value will be base64 encoded.
- Inside the JWT body, we can store details related to user, roles, token issue time, expiry time, who issued the token?, who signed the token? etc. which can be later used for AuthN and AuthZ. The body value will be base64 encoded.
- Once the login operation is successful, the backend will generate a JWT token. Backend server can sign this token. The signature part can be used to validate if token was tampered.

### How to make sure token was not tampered?

- To make sure that no one tampered the data on the network, we can sign the token when it is generated. To create the signature part, you have to take the encoded header, encoded body, a secret and the algorithm specified in header, and sign that.

For example if using HMAC SHA256 algorithm, the signature will be created in the following way:
```
HMACSHA256(base64EncodedHeader + "." + base64EncodedPayload, secret)
```
This secret value would only be known the backend.

- At the time of JWT validation, the signature will again be generated using JWT header and body sent from client to backend, and if that won't match with JWT signature then that would imply the token was tampered.
- Important thing, HMAC SHA256 is a hashing algorithm which is non-reversible i.e. the secret cannot be determined from the signature value.

### Making the project config use JWT token

```
// With SessionCreationPolicy.STATELESS we are telling Spring Security framework to not generate any JSessionIds/Http Sessions
http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
```

## Method Level Security

- Apart from applying authorization rules on the API paths/URLs using spring security, method level security allows to apply the authorization rules on any method in the application.
- Method level security will also help enforce authorization rules in non-web apps where we will not have any endpoints.
- Method level security provides below approaches to apply the authorization rules and executing the business logic -
    - Invocation authorization: Validates if someone can invoke a method or not based on their roles/authorities.
    - Filtering authorization: Validates what a method can receive through its parameters and what the invoker can receive back from the method post business logic execution.
- To enable this, we need to mention @EnableMethodSecurity annotation on the @Configuration class. prePostEnabled property needs to be set as true inside this annotation to enable @PreAuthorize and @PostAuthorize annotations.

### PreAuthorize and PostAuthorize

- @PreAuthorize can be used to determine invocation of the method on basis of user's role, authority or even on basis of some input parameter value.
- @PostAuthorize will not stop execution of the method, it would rather make the execution to complete. And once the execution is complete, it would be used to determine whether it has to return output back to the user or not on basis of user's role, authority or even on basis of return object.
 
Note:
- @PreFilter("filterObject.contactName != 'Test'") can be used to filter parameters before calling the method, the filterObject should be of type Collection interface.
- Similarly, @PostFilter("filterObject.contactName != 'Test'") can be used to filter parameters after executing the method, the filterObject should be of type Collection interface.

## OAuth2

Problem statement:
- So maintaining authentication and authorization requirements in every service is tedious. We should move the entire security logic to a common component, so all apps can work with this common component for AuthNZ of an end user.

Solution:
- OAuth2.
- OAuth2 recommends to maintain an Auth server which will have logic for AuthNZ.
- Example: If a 3rd party app asks for google credentials then google auth server responds with a token which gives them read access over some user data.

### Introduction
- OAuth2 is a specification/interface/protocol which only defines the standards, and there is no implementation code written as part of this OAuth2.
- Access token, an important concept of OAuth2, is used to grant permissions and determines what actions 3rd party or app can perform.
- OAuth2 framework has various grant types for different use-cases. Grant type is a flow of AuthNZ of an end user or an app. Using these grant types flows the access token would be issued.
- More: oauth2.net/2

### OAuth2 Terminologies
- Resource owner: It is you the end user i.e. the user who owns the resource.
- Client: The client/website which interacts with backend after taking permission from the resource owner.
- Auth server: Server which knows about the resource owner. Resource owner should have an account in this server.
- Resource server: Server where the APIs that the client want to consume are hosted.
- Scopes: There are the granular permissions which the client wants such as access to data or perform some actions.

Note: The client, which makes request on behalf of resource owner, will have a client-id and client-secret.

### authorization_code grant flow
- For Authorization code grant type, the resource owner will first send request to Auth server via client which will return the authorization code. Client would then send a request to get access token using this authorization code.
- First request would have the client_id value and response_type as code along with user credentials (will be asked when login page for Auth server is opened), and in the next request client_id, client_secret and auth code would be sent to get access token.
- authorization_code is recommended for communication when resource_owner is involved in granting access.
    - For UI apps. 
- oauth.com/playground

### client_credentials grant flow
- In client_credentials grant_type, when client is making request to auth server endpoint, it has to send the client_id & client_secret details and grant_type with value 'client_credentials'.
- We use this auth flow only if there is no user and UI involved. Like in the scenarios where 2 different applications want to share data between them using backend APIs.
- client_credentials is recommended for communication b/w 2 backend applications (no resource_owner is picture).

### refresh_token grant flow
- When the access token issued by Auth server becomes expired then we can use refresh_token grant type, rather than asking user for creds again.
- In refresh_token grant_type, client (like 3rd party app on behalf of user) is making request to auth server to get a fresh access token. In the request for same, the client_id, client_secret, refresh_token would be sent to the auth server.

### How would resource server validate the access token issued by auth server?
- One way which is recommended is to use the same key or secret which auth server used to sign the token in the resource server to check if token was tampered or not, similar was done for JWT token.

## OpenID Connect (OIDC)
- It is a protocol on top of OAuth2 framework. 
- While OAuth2 provides authorization via access token containing scopes, OpenID connect provides authentication by introducing a new ID token which contains a set of info and claims specifically for identity. 
- With this id token, it would contain a new set of info and claims specifically for identity.
- The OpenID flow is same as OAuth, the only difference is that in the initial request a specific scope of openid is used, and in the final exchange the client receives both an access token and an id token.

Important:
- At the core of authZ is OAuth2 but OAuth2 lacks an authN component. Implementing OpenID Connect on top of OAuth2 completes an IAM (Identity and Access Management) strategy.
- With OpenID connect, apps can share the identities easily.
- ID token is in JWT format. OIDC standardises the scopes to openid, profile, email and address.
- It is recommended to use OpenID Connect as it gives both access token and id token.

## KeyCloak
- KeyCloak, Okta, forgerock, Amazon Cognito, etc. provide authorization servers.
- KeyCloak is open source, other options are commercial. https://www.keycloak.org

### Realm
- Realm is a space inside auth server and using this space we can have own users, roles, client created. And whatever is created in a particular realm would have a boundary.
- We can realm for each env like dev, test, prod.
- Create realm for bankdev: http://localhost:8180/admin/master/console/#/bankdev

Note:
- This dependency will make the spring boot web app into a resource server i.e. web app will always expect access token for the secured request configured with spring security framework
```
<!-- This dependency will make the spring boot web app into a resource server i.e. web app will always expect access token for the secured request configured with spring security framework -->
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
```
- Deleted AuthProvider and UserDetails classes since Auth was be performed using DB but now it would be performed using KeyCloak Auth server.
- For UI app, we cannot store client_id and client_secret in the js code and authorization_code grant type should be used, unlike client_credentials grant type which can be used for communication b/w backend services.

On KeyCloak,
- A client can be created which is granted to do authorization_code flow for retrieving token, this is required for UI app.
- Similarly, a client can be created and granted client_credentials flow to retrieve tokens for backend to backend app communication i.e. when no user is involved.

Note: Every client will have a scope which would determine what values they can get.
